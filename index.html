<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Musik Koffer – Workbench (BW, Hard Overrides)</title>
  <style>
    /* ---- HARD RESET (overrides WP/themes) ---- */
    html, body { background:#fff !important; color:#000 !important; margin:0; padding:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    *, *::before, *::after { box-sizing:border-box; }
    /* Containers */
    header, .wrap, main, aside, pre, #reviewPanel, #toc { background:#fff !important; color:#000 !important; }
    /* Borders */
    header, aside, pre, #reviewPanel { border:1px solid #000 !important; }
    /* Buttons */
    button { background:#fff; color:#000; border:1px solid #000; }
    button:disabled { opacity:.6 }
    /* Layout */
    :root { --pad:16px; --nav-w: clamp(220px, 22vw, 360px); }
    header { display:flex; gap:8px; align-items:center; padding:12px var(--pad); border-width:0 0 1px 0 !important; }
    header h1 { margin:0; font-size:1.35rem; flex:1 }
    #status { font-size:.9rem }
    #err { color:#b00020 !important; white-space:pre-wrap; display:none }
    .badge { display:none; margin-left:.4rem; padding:.1rem .4rem; border:1px solid #000; background:#000; color:#fff }
    .wrap { display:grid; grid-template-columns:var(--nav-w) 1fr; min-height:calc(100vh - 64px) }
    aside { position:sticky; top:64px; height:calc(100vh - 64px); overflow:auto; padding:12px }
    main { padding:clamp(12px,2vw,24px) }
    .toc a { display:block; padding:12px; text-decoration:none; color:#000; border-bottom:1px solid #000 }
    .toc a:hover, .toc a.active { background:#000 !important; color:#fff !important; }
    #chapterTitle { margin:.2rem 0 .6rem 0; font-size:1.3rem }
    pre { white-space:pre-wrap; word-wrap:break-word; padding:16px; line-height:1.45 }
    /* Global FAB – always visible */
    #navFab {
      position:fixed; right:16px; bottom:16px; z-index:2147483647;
      padding:.65rem 1rem; border:2px solid #000; background:#000; color:#fff; font-weight:700;
      box-shadow:none; cursor:pointer; border-radius:8px;
      pointer-events:auto;
    }
    #navFab:focus { outline:2px solid #111; outline-offset:2px }
    /* Mobile drawer behaviour */
    @media (max-width: 900px){
      .wrap { grid-template-columns:1fr }
      aside {
        position:fixed; inset:auto 0 0 0; top:0; height:100vh; width:82vw; max-width:430px;
        transform:translateX(-100%); transition:transform .2s ease; box-shadow:0 0 0 9999px rgba(0,0,0,.25); z-index:1000;
      }
      body.nav-open aside { transform:none }
    }
  </style>
</head>
<body>
<header>
  <h1>Musik Koffer – Workbench</h1>
  <div id="status">Bereit. Kapitel wählen …</div>
  <div id="err"></div>
  <div class="toolbar">
    <button id="btnOpenReview">Kommentar-Review <span id="badgeComments" class="badge">0</span></button>
    <button id="btnExportJSON2" disabled>JSON 2 erzeugen</button>
  </div>
</header>

<!-- Floating global button -->
<button id="navFab" aria-expanded="false" aria-controls="nav" aria-label="Inhaltsverzeichnis öffnen oder schließen">☰ Inhalt</button>

<div class="wrap">
  <aside id="nav" aria-label="Inhaltsverzeichnis">
    <div id="toc" class="toc">Manifest wird geladen …</div>
  </aside>
  <main>
    <h2 id="chapterTitle">Kapitel</h2>
    <pre id="chapterContent">Bitte Kapitel im Inhaltsverzeichnis wählen…</pre>
    <div id="reviewPanel" style="display:none"></div>
  </main>
</div>

<script>
// --- Config ---
const MANIFEST_URL = 'https://stickysmart.github.io/MusikKoffer/chapter/manifest.json';
const REPO_ROOT = MANIFEST_URL.replace(/\/chapter\/manifest\.json.*$/, '/');

function resolveUrl(path){
  if(!path) return '';
  if(/^https?:\/\//i.test(path)) return path;
  if(path.startsWith('/')) return REPO_ROOT.replace(/\/$/,'') + path;
  return REPO_ROOT + path.replace(/^\/?/,''); 
}
function pagesToRaw(url){
  const m = url.match(/^https?:\/\/([^\/]+)\.github\.io\/([^\/]+)\/(.+)$/i);
  if(!m) return url;
  const user=m[1], repo=m[2], rest=m[3];
  return `https://raw.githubusercontent.com/${user}/${repo}/main/${rest}`;
}

// --- Store & helpers ---
function ensureStore(){ window.DATA = window.DATA || {records:[],meta:{},comments:[]}; return window.DATA; }
function unresolvedCount(s){ return (s.comments||[]).filter(c=>c.status==='open').length; }
function canExportJSON2(s){ return unresolvedCount(s)===0; }
function setStatus(t){ const el=document.querySelector('#status'); if(el) el.textContent = t; }
function setErr(t){ const el=document.querySelector('#err'); if(!el) return; if(t){ el.style.display='block'; el.textContent=t; } else { el.style.display='none'; el.textContent=''; } }
function enforceExportGuard(s){
  const btn=document.querySelector('#btnExportJSON2');
  const badge=document.querySelector('#badgeComments');
  const n=unresolvedCount(s);
  if(badge){ badge.textContent=n; badge.style.display = n? 'inline-block':'none'; }
  if(btn){ btn.disabled=!canExportJSON2(s); btn.title = btn.disabled ? 'Export gesperrt: erst Kommentare erledigen.' : 'Bereit für JSON 2.'; }
}
async function fetchText(url){ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(url+' → '+r.status); return await r.text(); }
async function fetchJSON(url){ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(url+' → '+r.status); return await r.json(); }

// --- MD parsing ---
function extractDataBlocks(md){
  const re=/```(json|yaml)\s+data:(append|upsert|remove)(?:\s+key=([A-Za-z0-9_-]+))?\s*([\s\S]*?)```/g;
  const out=[]; let m; while((m=re.exec(md))!==null){ out.push({lang:m[1],op:m[2],key:m[3]||'id',body:m[4].trim()}); } return out;
}
function parseJSONRelaxed(txt){ return JSON.parse(txt.replace(/\/\/.*$/mg,'').replace(/\/\*[\s\S]*?\*\//g,'')); }
function indexBy(arr,key){ const m=new Map(); for(const o of arr) m.set(o[key],o); return m; }
function upsertMany(store,arr,key){ const m=indexBy(store.records,key); for(const o of arr){ const k=o[key]; if(m.has(k)){ Object.assign(m.get(k),o);} else { store.records.push(o); m.set(k,o);} } }
function removeMany(store,ids,key){ const set=new Set(ids); store.records=store.records.filter(o=>!set.has(o[key])); }
function addComment(store,{targetKey,text}){ const id='C'+Math.random().toString(36).slice(2,8); store.comments.push({id,targetKey,text,createdAt:new Date().toISOString(),status:'open'}); }

async function importFromMarkdown(mdUrl){
  const s=ensureStore();
  const before = new Map(s.records.map(r=>[r.id, JSON.stringify(r)]));

  let md;
  try {
    md = await fetchText(mdUrl);
  } catch (e) {
    const raw = pagesToRaw(mdUrl);
    try{
      md = await fetchText(raw);
      setErr('Laden fehlgeschlagen: '+mdUrl+' → RAW-Fallback genutzt.');
    }catch(e2){
      setErr('Laden fehlgeschlagen: '+mdUrl+'\nund RAW-Fallback: '+raw+'\n('+ (e2?.message||e2) +')');
      throw e2;
    }
  }

  const fm = md.match(/^---\n([\s\S]*?)\n---/);
  if(fm){ s.meta = s.meta || {}; s.meta.frontmatter = fm[1]; }

  for(const b of extractDataBlocks(md)){
    const payload = parseJSONRelaxed(b.body);
    if(b.op==='append'){ const arr=Array.isArray(payload)?payload:[payload]; s.records.push(...arr); }
    if(b.op==='upsert'){ const arr=Array.isArray(payload)?payload:[payload]; upsertMany(s,arr,b.key); }
    if(b.op==='remove'){ const ids=Array.isArray(payload)?payload:[payload]; removeMany(s,ids,b.key); }
  }

  const seen = new Set();
  for(const rec of s.records){
    seen.add(rec.id);
    const prev = before.get(rec.id);
    const now = JSON.stringify(rec);
    if(prev===undefined) addComment(s,{targetKey:rec.id,text:`Neuer Datensatz: ${rec.title??rec.id} prüfen.`});
    else if(prev!==now) addComment(s,{targetKey:rec.id,text:`Änderungen an ${rec.title??rec.id} sichten.`});
  }
  for(const [id] of before){ if(!seen.has(id)) addComment(s,{targetKey:id,text:`Datensatz entfernt: ${id}. Korrekt?`}); }
  enforceExportGuard(s);
  return {md};
}

// --- TOC ---
function cleanFileLabel(filename){
  return filename.replace(/^[0-9]+[\s_\-–]*?/,'').replace(/\.md$/i,'').replace(/_/g,' ');
}
async function buildTOC(){
  try{
    setErr(''); setStatus('Manifest laden …');
    const mf = await fetchJSON(MANIFEST_URL);
    const raw = (mf.chapters||[]).filter(Boolean);
    const toc = document.querySelector('#toc');

    const items = raw.map((entry, idx)=>{
      if (typeof entry === 'string') {
        const file = entry.split('/').pop();
        const label = `${String(idx+1).padStart(2,'0')} – ${cleanFileLabel(file)}`;
        const url = resolveUrl(entry);
        return {label, url};
      } else {
        const path = entry.path || '';
        const url = resolveUrl(path);
        const id  = (entry.id != null) ? String(entry.id).padStart(2,'0')+' – ' : '';
        const label = id + (entry.title || cleanFileLabel(path.split('/').pop()));
        return {label, url};
      }
    });

    toc.innerHTML = items.map(it=>`<a href="#" data-url="${it.url}">${it.label}</a>`).join('');

    toc.addEventListener('click', async (e)=>{
      const a = e.target.closest('a'); if(!a) return;
      e.preventDefault();
      document.querySelectorAll('.toc a').forEach(el=>el.classList.remove('active'));
      a.classList.add('active');
      const url = a.getAttribute('data-url');
      setStatus('Kapitel laden …');
      try{
        const {md} = await importFromMarkdown(url);
        document.querySelector('#chapterTitle').textContent = a.textContent;
        document.querySelector('#chapterContent').textContent = md;
        setStatus('Fertig. '+unresolvedCount(ensureStore())+' offene Kommentare.');
      }catch(err){}
      if (window.matchMedia('(max-width: 900px)').matches) toggleNav(false);
      // Fokus auf Kapitel
      document.querySelector('#chapterTitle').scrollIntoView({behavior:'smooth',block:'start'});
    });

    setStatus('Bereit. Kapitel wählen …');
  }catch(e){
    setStatus('');
    setErr('Manifest konnte nicht geladen werden: '+(e?.message||e));
    document.querySelector('#toc').textContent = 'Manifest-Fehler.';
  }
}

// --- Review & Export ---
document.querySelector('#btnOpenReview').addEventListener('click', ()=>{
  const p=document.querySelector('#reviewPanel');
  p.style.display = p.style.display==='block' ? 'none':'block';
});
document.querySelector('#btnExportJSON2').addEventListener('click', ()=>{
  const s=ensureStore(); if(!canExportJSON2(s)){ alert('Export gesperrt: Es sind noch offene Kommentare vorhanden.'); return; }
  const blob=new Blob([JSON.stringify({version:s.meta?.version||'dev',updated:new Date().toISOString(),items:s.records},null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob); const a=Object.assign(document.createElement('a'),{href:url,download:'export_JSON2.json'}); a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500);
});

// --- FAB toggle ---
const fab = document.getElementById('navFab');
function toggleNav(force){
  const open = (typeof force==='boolean') ? force : !document.body.classList.contains('nav-open');
  document.body.classList.toggle('nav-open', open);
  fab?.setAttribute('aria-expanded', String(open));
  if(open){ document.querySelector('#toc')?.scrollIntoView({behavior:'smooth', block:'nearest'}); }
}
fab?.addEventListener('click', (e)=>{ e.stopPropagation(); toggleNav(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') toggleNav(false); });
document.addEventListener('click', (e)=>{
  if(document.body.classList.contains('nav-open')){
    const a = document.getElementById('nav');
    if(a && !a.contains(e.target) && e.target!==fab){ toggleNav(false); }
  }
});

// --- Boot ---
window.addEventListener('DOMContentLoaded', buildTOC);
</script>
</body>
</html>
